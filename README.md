# OCA 3 базовые java API

1) класс String

Вы можете заметить, что Stringкласс не указан в целях OCP. Тем не менее, он используется в большинстве вопросов для вывода. Мы не хотим, чтобы вы задавали вопрос по другой теме неправильно, потому что вы забыли, как работает конкатенация! Как вы знаете, stringэто последовательность символов.
Поскольку Stringв программе так много объектов, Stringкласс is finalи Stringобъекты неизменны. Значение не может изменяться в неизменяемом объекте, как обсуждалось в главе 2. Это позволяет оптимизировать Java, сохраняя строковые литералы в string pool. Это также означает, что вы можете сравнивать строковые литералы с ==. Тем не менее, сравнивать все же неплохо equals(), поскольку Stringобъекты, созданные с помощью конструктора или вызова метода, не всегда совпадают при использовании сравнения с ==. Вот пример:
4:    String s1 = "bunny";
5:    String s2 = "bunny";
6:    String s3 = new String("bunny");
7:    System.out.println(s1 == s2);        // true
8:    System.out.println(s1 == s3);        // false
9:    System.out.println(s1.equals(s3));   // true
Строка 7 печатает , trueтак как s1и s2ссылки указывают на то же литерала в строке пула. Строка 8 печатается, falseпотому что строка 6 намеренно создает новый объект в памяти, вызывая конструктор. Строка 9 возвращает значение, trueпотому что значения совпадают, даже если местоположение в памяти не совпадает.
Поскольку Stringтакой фундаментальный класс, Java позволяет использовать +оператор для их объединения, который называется concatenation. Конкатенация - это большое слово, но оно просто означает создание нового Stringсо значениями из обеих исходных строк. Помните, что Java обрабатывает эти операторы слева направо. Также помните, что Stringсцепленный с чем-либо еще является String. Вы видите, что отличает эти два примера?

10:   String s4 = "1" + 2 + 3;
11:   String s5 = 1 + 2 + "3";
12:   System.out.println(s4);  // 123
13:   System.out.println(s5);  // 33
Строка 12 выводится на печать, 123потому что она видит Stringсначала, а затем продолжает сцепляться, создавая новые строки. Строка 13 видит два числа, которые нужно добавить первыми, и делает это, используя целочисленную арифметику. Только в конце строки он видит Stringи может объединять.
Наконец, вот пример, который использует общие Stringметоды:
14:   String s = "abcde ";
15:   System.out.println(s.trim().length());               // 5
16:   System.out.println(s.charAt(4));                     // e
17:   System.out.println(s.indexOf('e'));                  // 4
18:   System.out.println(s.indexOf("de"));                 // 3
19:   System.out.println(s.substring(2, 4).toUpperCase()); // CD
20:   System.out.println(s.replace('a', '1'));             // 1bcde
21:   System.out.println(s.contains("DE"));                // false
22:   System.out.println(s.startsWith("a"));               // true
Строка 15 показывает, что trim()удаляет любые пробельные символы из начала и конца a String. Строка 16 напоминает нам, что Java начинает считать индексы с 0 вместо 1. Строки 17 и 18 показывают, что мы можем найти нулевой индекс символа или a String. Строка 19 создает меньшее Stringиз индекса 2 справа перед индексом 4. Затем она использует метод цепочки для преобразования его Stringв заглавные буквы. Строка 20 выполняет замену персонажа. Строки 21 и 22 выполняют простой Stringпоиск.
Поскольку Stringон неизменен, он неэффективен, когда вы обновляете значение в цикле. StringBuilderлучше для этого сценария. А StringBuilderесть mutable, что означает, что он может изменить стоимость и увеличить емкость. Если несколько потоков обновляют один и тот же объект, вы должны использовать StringBufferвместо StringBuilder.
В качестве обзора StringBuilderкода, посмотрите, помните ли вы, почему каждая из этих строк выводит то, что она делает:
3:    StringBuilder b = new StringBuilder();
4:    b.append(12345).append('-');
5:    System.out.println(b.length());        // 6
6:    System.out.println(b.indexOf("-"));    // 5
7:    System.out.println(b.charAt(2));       // 3
8:
9:    StringBuilder b2 = b.reverse();
10:   System.out.println(b.toString());      // -54321
11:   System.out.println(b == b2);           // true
Строка 3 создает пустое StringBuilder. Строка 4 использует цепочку методов для выполнения нескольких вызовов методов и добавляет два разных типа в StringBuilder. В строке 5 естьшесть символов в b. Пять чисел от intи шестой тире. В строке 6 последний индекс объясняется 5тем, что Java начинает считать индексы с 0. Аналогично, в строке 7 второй индекс является третьим символом, которым является 3. В строке 9 мы инвертируем StringBuilderи возвращаем ссылку на тот же объект. Строка 10 печатает это обратное значение, а строка 11 подтверждает, что это тот же объект.
А теперь еще немного:
12:   StringBuilder s = new StringBuilder("abcde");
13:   s.insert(1, '-').delete(3, 4);
14:   System.out.println(s);                 //a-bde
15:   System.out.println(s.substring(2, 4)); // bd
В строке 13 используется цепочка. Мы вставляем в индекс, который находится прямо перед вторым символом b, создавая строку a-bc. Затем мы удаляем из третьего индекса вплоть до четвертого индекса, который оказывается только одним символом c. В строке 15 мы получаем символы, начинающиеся с индекса 2и заканчивающиеся непосредственно перед индексом 4. Это два персонажа bd.
Таблица 5.5 Отзывы о различиях между String, StringBuilderи StringBuffer. Если это все еще нечетко, перед тем как продолжить, пожалуйста, получите учебные материалы в ОСА.
Таблица 5.5 СравнениеString,StringBuilderиStringBuffer
	String	StringBuilder	StringBuffer
Immutable?	да	нет	нет
Pooled? Объединенный?
	да	нет	нет
Thread-safe?	да	нет	да
Can change size?
Можно изменить размер?	нет	да	да



2 Методы ArrayList

Вы также должны знать, что ArrayListреализует, toString()чтобы вы могли легко увидеть содержимое, просто распечатав его. Массивы не производят такой красивый вывод.
Добавить() 
add()ArrayList

boolean add(E element)
void add(int index, E element)
Не беспокойтесь о booleanвозвращаемом значении. Это всегда возвращается true. Это происходит потому, что при добавлении элемента другим классам в семействе коллекций требуется возвращаемое значение в сигнатуре.
Поскольку add()это наиболее важный ArrayListметод, который вам нужно знать для экзамена, мы собираемся показать несколько примеров для него. Давайте начнем с самого простого случая:

ArrayList list = new ArrayList();
list.add("hawk");          // [hawk]
list.add(Boolean.TRUE);    // [hawk, true]
System.out.println(list);  // [hawk, true]
add() делает именно то, что мы ожидаем: он хранит Stringв более не пустой ArrayList. Затем он делает то же самое для boolean. Это нормально, потому что мы не указали тип для ArrayList; следовательно, тип is Object, который включает в себя все, кроме примитивов. Возможно, это не то, что мы намеревались, но компилятор этого не знает. Теперь давайте воспользуемся обобщениями, чтобы сообщить компилятору, что мы хотим разрешить только Stringобъекты в нашем ArrayList:

ArrayList<String> safer = new ArrayList<>();
safer.add("sparrow");
safer.add(Boolean.TRUE);    // DOES NOT COMPILE
На этот раз компилятор знает, что в Stringнего разрешены только объекты, и предотвращает попытку добавления boolean. Теперь давайте попробуем добавить несколько значений в разные позиции.

4: List<String> birds = new ArrayList<>();
5: birds.add("hawk");            // [hawk]
6: birds.add(1, "robin");        // [hawk, robin]
7: birds.add(0, "blue jay");     // [blue jay, hawk, robin]
8: birds.add(1, "cardinal");     // [blue jay, cardinal, hawk, robin]
9: System.out.println(birds);    // [blue jay, cardinal, hawk, robin]
Если в вопросе есть код, который добавляет объекты в индексированных позициях, нарисуйте его, чтобы не потерять отслеживание того, какое значение имеет какой индекс. В этом примере строка 5 добавляет "hawk"к концу birds. Затем строка 6 добавляет "robin"к индексу 1 of birds, который оказывается концом. Строка 7 добавляет "blue jay"к индексу 0, который является началом birds. Наконец, строка 8 добавляет "cardinal«к индексу 1, который сейчас находится в середине birds.
Удалить()
Эти remove()способы удаления первого соответствующее значение в ArrayListили удалить элемент по указанному индексу. Подписи метода следующие:

boolean remove(Object object)
E remove(int index)

На этот раз booleanвозвращаемое значение говорит нам, было ли найдено совпадение. Тип Eвозвращаемого значения - это элемент, который фактически был удален. Ниже показано, как использовать эти методы:
3: List<String> birds = new ArrayList<>();
4: birds.add("hawk");     // [hawk]
5: birds.add("hawk");     // [hawk, hawk]
6: System.out.println(birds.remove("cardinal")); // prints false
7: System.out.println(birds.remove("hawk")); // prints true
8: System.out.println(birds.remove(0)); // prints hawk
9: System.out.println(birds);     // []
Линия 6 пытается удалить элемент, которого нет в birds. Возвращается, falseпотому что такой элемент не найден. Строка 7 пытается удалить элемент, который находится внутри, birdsи поэтому возвращает true. Обратите внимание, что он удаляет только одно совпадение. Строка 8 удаляет элемент с индексом 0, который является последним оставшимся элементом в ArrayList.
Поскольку при вызове remove()с intиспользованием индекса индекс, который не существует, вызовет исключение. Например, birds.remove(100)кидает IndexOutOfBoundsException.
Также есть removeIf()метод. Мы рассмотрим это в следующей главе, потому что она использует лямбда-выражения (тема в этой главе).
набор()
set()Метод изменяет один из элементов ArrayListбез изменения размера. Подпись метода выглядит следующим образом:

E set(int index, E newElement)
Тип Eвозврата - это элемент, который был заменен. Ниже показано, как использовать этот метод:
15: List<String> birds = new ArrayList<>();
16: birds.add("hawk");                    // [hawk]
17: System.out.println(birds.size());     // 1
18: birds.set(0, "robin");               // [robin]
19: System.out.println(birds.size());     // 1
20: birds.set(1, "robin");               // IndexOutOfBoundsException
Строка 16 добавляет один элемент в массив, делая размер 1. Строка 18 заменяет этот один элемент, а размер остается равным 1. Строка 20 пытается заменить элемент, которого нет в ArrayList. Поскольку размер равен 1, единственным допустимым индексом является 0. Java выдает исключение, поскольку это недопустимо.
isEmpty () и size ()
isEmpty()И size()методы посмотреть на сколько слотов используются. Подписи метода следующие:

boolean isEmpty()
int size()
Ниже показано, как использовать эти методы:

System.out.println(birds.isEmpty());     // true
System.out.println(birds.size());     // 0
birds.add("hawk");                    // [hawk]
birds.add("hawk");                    // [hawk, hawk]
System.out.println(birds.isEmpty());     // false
System.out.println(birds.size());     // 2


В начало, birdsимеет размер 0 и является пустым. Емкость больше 0. Но, как и в случае StringBuilder, мы не используем емкость при определении размера или длины. После добавления элементов размер становится положительным, и он больше не является пустым.
Чисто()
clear()Метод обеспечивает простой способ отбросить все элементы ArrayList. Подпись метода выглядит следующим образом:
void clear()

Ниже показано, как использовать этот метод:

List<String> birds = new ArrayList<>();
birds.add("hawk");                    // [hawk]
birds.add("hawk");                    // [hawk, hawk]
System.out.println(birds.isEmpty());     // false
System.out.println(birds.size());     // 2
birds.clear();                         // []
System.out.println(birds.isEmpty());     // true
System.out.println(birds.size());     // 0
После того clear(), как мы позвоним , birdsснова станет пустым ArrayListразмером 0.
содержит()
В contains()метод проверяет , является ли определенное значение в ArrayList. Подпись метода выглядит следующим образом:
boolean contains(Object object)
Ниже показано, как использовать этот метод:

List<String> birds = new ArrayList<>();
birds.add("hawk");                         // [hawk]
System.out.println(birds.contains("hawk")); // true
System.out.println(birds.contains("robin")); // false
Этот метод вызывает equals()каждый элемент, ArrayListчтобы увидеть, есть ли совпадения. Поскольку Stringреализует equals(), это работает хорошо.
равна ()
Наконец, ArrayListимеет собственную реализацию, equals()так что вы можете сравнить два списка, чтобы увидеть, содержат ли они одинаковые элементы в одинаковом порядке.

boolean equals(Object object)
ниже показан пример:

31: List<String> one = new ArrayList<>();
32: List<String> two = new ArrayList<>();
33: System.out.println(one.equals(two));      // true
34: one.add("a");                         // [a]
35: System.out.println(one.equals(two));     // false
36: two.add("a");                         // [a]
37: System.out.println(one.equals(two));     // true
38: one.add("b");                         // [a,b]
39: two.add(0, "b");                    // [b,a]
40: System.out.println(one.equals(two));     // false
В строке 33 два ArrayListобъекта равны. Пустой список - это, безусловно, те же элементы в том же порядке. В строке 35 ArrayListобъекты не равны, потому что размер отличается. В строке 37 они снова равны, потому что один и тот же элемент находится в каждом. В строке 40 они не равны. Размер одинаковый, а значения одинаковые, но они не в том же порядке.

3)Классы Обертки

До сих пор мы помещали Stringобъекты только в ArrayList. Что произойдет, если мы хотим добавить примитивы? Каждый тип примитива имеет класс-оболочку, который является типом объекта, который соответствует примитиву. В таблице 3.2 перечислены все классы-обертки вместе с конструктором для каждого.
Таблица 3.2. Классы Wrapper
Примитивный тип	Класс Wrapper	Пример построения
boolean	Boolean	newBoolean(true)
Byte	Byte	new Byte((byte) 1)
Short	Short	new Short((short) 1)
Int	Integer	new Integer(1)
Long	Long	new Long(1)
Float	Float	new Float(1.0)
Double	Double	new Double(1.0)
Char	Character	new Character('c')

